// Copyright 2021 Axiom-Team
//
// This file is part of Duniter-v2S.
//
// Duniter-v2S is free software: you can redistribute it and/or modify
// it under the terms of the GNU Affero General Public License as published by
// the Free Software Foundation, version 3 of the License.
//
// Duniter-v2S is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Affero General Public License for more details.
//
// You should have received a copy of the GNU Affero General Public License
// along with Duniter-v2S. If not, see <https://www.gnu.org/licenses/>.

#![cfg(feature = "constant-fees")]

mod common;

use codec::Encode;
use common::*;
use frame_support::{assert_ok, traits::StoredMap};
use gtest_runtime::*;
use sp_keyring::sr25519::Keyring;
use sp_runtime::MultiAddress;

#[test]
fn test_change_owner_key_with_batch_all_claim_transfer_all() {
    ExtBuilder::new(1, 3, 4)
        .with_initial_balances(vec![(Keyring::Dave.to_account_id(), 1_000)])
        .build()
        .execute_with(|| {
            run_to_block(4);

            let genesis_hash = System::block_hash(0);
            let dave = Keyring::Dave.to_account_id();
            let ferdie = Keyring::Ferdie.to_account_id();
            let dave_initial_balance = Balances::free_balance(dave.clone());
            let payload = (b"icok", genesis_hash, 4u32, dave.clone()).encode();
            let signature = Keyring::Ferdie.sign(&payload);

            assert_eq!(Identity::identity_index_of(&dave), Some(4));
            assert_eq!(Identity::identity_index_of(&ferdie), None);
            assert_eq!(Balances::free_balance(ferdie.clone()), 0);

            let batch_call = RuntimeCall::Utility(pallet_utility::Call::batch_all {
                calls: vec![
                    RuntimeCall::UniversalDividend(pallet_universal_dividend::Call::claim_uds {}),
                    RuntimeCall::Balances(pallet_balances::Call::transfer_all {
                        dest: MultiAddress::Id(ferdie.clone()),
                        keep_alive: false,
                    }),
                    RuntimeCall::Identity(pallet_identity::Call::change_owner_key {
                        new_key: ferdie.clone(),
                        new_key_sig: signature.into(),
                    }),
                ],
            });
            let batch_xt = get_unchecked_extrinsic(batch_call, Keyring::Dave, 0u64, 0);
            assert_ok!(Executive::apply_extrinsic(batch_xt));

            assert_eq!(Identity::identity_index_of(&dave), None);
            assert_eq!(Identity::identity_index_of(&ferdie), Some(4));
            assert_eq!(
                frame_system::Pallet::<Runtime>::get(&ferdie).linked_idty,
                Some(4)
            );
            assert_eq!(Balances::free_balance(dave.clone()), 0);
            assert!(Balances::free_balance(ferdie.clone()) >= dave_initial_balance);

            // Refund generated by the batch extrinsic itself must target the new owner key.
            let queued_refund = pallet_quota::RefundQueue::<Runtime>::get()
                .iter()
                .find(|refund| refund.identity == 4u32)
                .cloned()
                .expect("batch extrinsic should have queued a refund");
            assert_eq!(queued_refund.account, ferdie.clone());
            assert!(queued_refund.amount > 0);
            let ferdie_balance_before_refund = Balances::free_balance(ferdie.clone());

            // Advance one block to execute quota on_idle processing.
            let block_after_refund = System::block_number() + 1;
            run_to_block(block_after_refund);

            assert!(pallet_quota::RefundQueue::<Runtime>::get().is_empty());
            let refunded_amount = System::events()
                .iter()
                .find_map(|event_record| match &event_record.event {
                    RuntimeEvent::Quota(pallet_quota::Event::Refunded {
                        who,
                        identity,
                        amount,
                    }) if who == &ferdie && *identity == 4u32 => Some(*amount),
                    _ => None,
                })
                .expect("quota refund should be emitted for the new key");
            assert!(refunded_amount > 0);
            assert_eq!(
                Balances::free_balance(ferdie.clone()),
                ferdie_balance_before_refund + refunded_amount
            );
            assert!(!System::events().iter().any(|event_record| {
                matches!(
                    &event_record.event,
                    RuntimeEvent::Quota(pallet_quota::Event::Refunded { who, .. })
                    if who == &dave
                )
            }));

            // Keep advancing blocks with on_idle enabled in the harness.
            run_to_block(block_after_refund + 1);
        })
}
