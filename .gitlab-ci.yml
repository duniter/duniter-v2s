# Runner tags:
# - podman: use 'podman' to build multiplatform images

stages:
  - gx_build
  - gx_package
  - gx_release
  - schedule
  - labels
  - quality
  - build
  - tests
  - deploy
  - deploy_readme

workflow:
  rules:
    - changes:
      - docker/Dockerfile
      - end2end-tests/**/*
      - node/**/*
      - pallets/**/*
      - runtime/**/*
      - .gitlab-ci.yml
      - Cargo.toml
      - Cargo.lock

sanity_tests:
  extends: .env
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule" && $SCHEDULE_TOPIC=="sanity-tests"'
    - when: never
  stage: schedule
  script:
    - cargo sanity-${CURRENCY}

check_labels:
  extends: .env
  stage: labels
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never
  script:
    - ./scripts/check_labels.sh $CI_MERGE_REQUEST_LABELS $CI_MERGE_REQUEST_MILESTONE

.env:
  image: paritytech/ci-linux:production
  tags:
    - kepler

fmt_and_clippy:
  extends: .env
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^wip*$/
      when: manual
    - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH == "master"'
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: manual
  stage: quality
  script:
    - cargo fmt -- --version
    - cargo fmt -- --check
    - cargo clippy -- -V
    - cargo clippy --all --tests -- -D warnings

.docker_build:
  stage: build
  script:
    - echo podman build --layers --tag "$IMAGE_NAME:$IMAGE_TAG" -f docker/Dockerfile $PODMAN_BUILD_OPTIONS .
    - podman build --layers --tag "$IMAGE_NAME:$IMAGE_TAG" -f docker/Dockerfile $PODMAN_BUILD_OPTIONS .
  tags:
    - podman

.docker_deploy:
  stage: deploy
  before_script:
    - podman login -u "duniterteam" -p "$DUNITERTEAM_PASSWD" docker.io
  tags:
    - podman

.docker_deploy_native:
  extends: .docker_deploy
  script:
    - podman push "localhost/$IMAGE_NAME:$IMAGE_TAG" "docker://docker.io/$IMAGE_NAME:$IMAGE_TAG"

.docker_deploy_multiplatform:
  extends: .docker_deploy
  script:
    - podman manifest rm "$MANIFEST" 2>/dev/null || true
    - podman build --layers --platform linux/amd64,linux/arm64 --manifest "$MANIFEST" -f docker/Dockerfile $PODMAN_BUILD_OPTIONS .
    - podman manifest push --all "$MANIFEST" "docker://docker.io/$IMAGE_NAME:$IMAGE_TAG"
  after_script:
    - podman manifest rm "$MANIFEST"
  variables:
    MANIFEST: "localhost/manifest-$IMAGE_NAME:$IMAGE_TAG"

build_debug:
  extends: .docker_build
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH == "master"'
    - when: never
  variables:
    IMAGE_NAME: "duniter/duniter-v2s"
    IMAGE_TAG: "debug-sha-$CI_COMMIT_SHORT_SHA"
    PODMAN_BUILD_OPTIONS: "--build-arg debug=1"

build_release:
  extends: .docker_build
  rules:
    - if: "$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ /^v*/"
    - if: '$CI_PIPELINE_SOURCE == "merge_request_event" || $CI_COMMIT_BRANCH == "master"'
    - when: manual
  variables:
    IMAGE_NAME: "duniter/duniter-v2s"
    IMAGE_TAG: "sha-$CI_COMMIT_SHORT_SHA"
    PODMAN_BUILD_OPTIONS: "--platform linux/amd64"

test_debug:
  stage: tests
  extends: .docker_build
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^wip*$/
      when: manual
    - if: $CI_COMMIT_TAG
      when: never
    - if: '$CI_MERGE_REQUEST_ID || $CI_COMMIT_BRANCH == "master"'
    - when: manual
  variables:
    IMAGE_NAME: "duniter/duniter-v2s-test"
    IMAGE_TAG: "debug-sha-$CI_COMMIT_SHORT_SHA"
    PODMAN_BUILD_OPTIONS: "--target build --build-arg debug=1 --build-arg cucumber=1"

test_release:
  stage: tests
  extends: .docker_build
  rules:
    - if: "$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ /^v*/"
    - when: never
  variables:
    IMAGE_NAME: "duniter/duniter-v2s-test"
    IMAGE_TAG: "sha-$CI_COMMIT_SHORT_SHA"
    PODMAN_BUILD_OPTIONS: "--target build --build-arg cucumber=1"

deploy_docker_debug_sha:
  stage: deploy
  extends: .docker_deploy_native
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH == "master"
  variables:
    IMAGE_NAME: "duniter/duniter-v2s"
    IMAGE_TAG: "debug-sha-$CI_COMMIT_SHORT_SHA"

deploy_docker_release_sha:
  stage: deploy
  extends: .docker_deploy_native
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: manual
  variables:
    IMAGE_NAME: "duniter/duniter-v2s"
    IMAGE_TAG: "sha-$CI_COMMIT_SHORT_SHA"

deploy_docker_release_sha_multiplatform:
  stage: deploy
  needs: ["deploy_docker_release_sha"]
  extends: .docker_deploy_multiplatform
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - when: manual
  variables:
    IMAGE_NAME: "duniter/duniter-v2s"
    IMAGE_TAG: "sha-$CI_COMMIT_SHORT_SHA"

deploy_docker_release_tag:
  stage: deploy
  extends: .docker_deploy_native
  rules:
    - if: "$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ /^v*/"
    - when: never
  variables:
    IMAGE_NAME: "duniter/duniter-v2s"
    IMAGE_TAG: "$CI_COMMIT_TAG"

deploy_docker_release_tag_multiplatform:
  stage: deploy
  needs: ["deploy_docker_release_tag"]
  extends: .docker_deploy_multiplatform
  rules:
    - if: "$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ /^v*/"
    - when: never
  script:
    - !reference [.docker_deploy_multiplatform, script]
    - podman manifest push --all "$MANIFEST" "docker://docker.io/$IMAGE_NAME:latest"
  variables:
    IMAGE_NAME: "duniter/duniter-v2s"
    IMAGE_TAG: "$CI_COMMIT_TAG"

readme_docker_release_tag:
  stage: deploy_readme
  needs: ["deploy_docker_release_tag"]
  rules:
    - if: "$CI_COMMIT_TAG && $CI_COMMIT_TAG =~ /^v*/"
    - when: never
  image:
    name: chko/docker-pushrm
    entrypoint: ["/bin/sh", "-c", "/docker-pushrm"]
  variables:
    DOCKER_USER: duniterteam
    DOCKER_PASS: "$DUNITERTEAM_PASSWD"
    PUSHRM_SHORT: "Duniter v2 based on Substrate framework"
    PUSHRM_TARGET: "docker.io/duniter/duniter-v2s"
    PUSHRM_DEBUG: 1
    PUSHRM_FILE: "$CI_PROJECT_DIR/docker/README.md"
  script: "/bin/true"

############## SRTOOL ##############

#.srtool:
#  stage: gx_build
#  rules:
#    - when: manual
#  image: paritytech/srtool:1.62.0
#  variables:
#    PACKAGE: $RUNTIME-runtime
#    RUNTIME_DIR: runtime/$RUNTIME
#    SRTOOL_OUTPUT: $CI_PROJECT_DIR/srtool_output.json
#  script:
#    - echo "Building runtime for $RUNTIME"
#    # Copy sources to the expected directory of srtool
#    - cp -R * /build/
#    # Build the runtime
#    - /srtool/build --app --json -cM > $SRTOOL_OUTPUT
#    - mv /build/runtime/$RUNTIME/target $CI_PROJECT_DIR/runtime/$RUNTIME/target/
#    - . $CARGO_HOME/env
#  artifacts:
#    name: "runtime"
#    paths:
#      - $CI_PROJECT_DIR/resources
#      - $CI_PROJECT_DIR/runtime/$RUNTIME/target/srtool/release/wbuild/$RUNTIME-runtime/
#      - $CI_PROJECT_DIR/srtool_output.json
#    expire_in: 1 day
#  tags:
#    - kepler
.srtool:
  stage: gx_build
  rules:
    - when: manual
      allow_failure: true
  image: paritytech/srtool:1.62.0
  script:
    - echo "Building runtime for $RUNTIME"
  tags:
    - kepler

gdev_srtool:
  extends: .srtool
  variables:
    RUNTIME: gdev

gtest_srtool:
  extends: .srtool
  variables:
    RUNTIME: gtest

g1_srtool:
  extends: .srtool
  variables:
    RUNTIME: g1

############## REBOOT ##############

#create_g1_data:
#  stage: gx_package
#  rules:
#    - when: always
#  image: python:3.9.18
#  script:
#    - echo "CrÃ©ation de g1-data.json"
#  tags:
#    - kepler
create_g1_data:
  stage: gx_package
  rules:
    - when: always
      allow_failure: true
  image: python:3.9.18
  variables:
    DEBIAN_FRONTEND: noninteractive
    LEVELDB_PATH: /dump/duniter_default/data/leveldb
  script:
    # Duniter 1.8.7 dump
    - mkdir /dump
    - cd /dump
    # Export file constructed using Duniter 1.8.7:
    #  - bin/duniter sync g1.cgeek.fr --store-txs --nointeractive --mdb 1.8.7
    #  - mkdir -p /tmp/backup-g1-duniter-1.8.7
    #  - cp -R $HOME/.config/duniter/1.8.7/data /tmp/backup-g1-duniter-1.8.7
    #  - cp -R $HOME/.config/duniter/1.8.7/g1 /tmp/backup-g1-duniter-1.8.7
    #  - cp -R $HOME/.config/duniter/1.8.7/txs.db /tmp/backup-g1-duniter-1.8.7
    #  - tar -cvzf /tmp/backup-g1-duniter-1.8.7.tgz /tmp/backup-g1-duniter-1.8.7
    # Then the file is uploaded to dl.cgeek.fr manually
    - curl https://dl.cgeek.fr/public/backup-g1-duniter-1.8.7.tgz -o g1-dump.tgz
    - tar xvzf g1-dump.tgz
    - rm g1-dump.tgz
    - mv backup-g1-duniter-1.8.7 duniter_default
    # py-g1-migrator conversion
    - git clone https://git.duniter.org/tools/py-g1-migrator.git -b import_identities_from_leveldb /py-g1-migrator
    - cd /py-g1-migrator
    - rm -rf inputs/*
    - apt-get update
    - apt-get install -y sqlite3 libleveldb-dev jq
    - pip install -r requirements.txt
    # Export identities and wallets
    - ./main.py
    # Export transaction history
    - sqlite3 /dump/duniter_default/txs.db --json "select time,comment,issuers,outputs from txs;" > inputs/transactions_history.json 2>> inputs/txs.err
    - ./generate_transactions_history.py
    # Merge in one file
    - 'jq -s "{ identities: .[0].identities, wallets: .[0].wallets, initial_monetary_mass: .[0].initial_monetary_mass, transactions_history: .[1] }" output/gtest_genesis.json output/history.json > output/g1-data.json'
    # Make the exported file available for next jobs
    - cp output/g1-data.json $CI_PROJECT_DIR/resources
  artifacts:
    paths:
      - $CI_PROJECT_DIR/resources
    expire_in: 1 day
  tags:
    - kepler

gdev_reboot:
  stage: gx_package
  rules:
    - when: manual
      allow_failure: true
  needs:
    - gdev_srtool
    - create_g1_data
  image: python:3.9.18
  script:
    - echo "Create release page"
  tags:
    - kepler
#create_gdev_raw_spec:
#  stage: gx_package
#  rules:
#    - when: never
#  image: rust:1-bullseye
#  variables:
#    DEBIAN_FRONTEND: noninteractive
#  script:
#    - apt-get update
#    - apt-get install -y clang cmake protobuf-compiler
#    - cargo run -- build-spec -lerror --chain=gdev_live --raw > resources/gdev-raw.json
#  artifacts:
#    name: "runtime"
#    paths:
#      - $CI_PROJECT_DIR/resources
#    expire_in: 1 day
#  tags:
#    - kepler
#

gtest_reboot:
  stage: gx_package
  rules:
    - when: manual
      allow_failure: true
  needs:
    - gtest_srtool
    - create_g1_data
  image: python:3.9.18
  script:
    - echo "Not implemented"
    - exit 1
  tags:
    - kepler

g1_reboot:
  stage: gx_package
  rules:
    - when: manual
      allow_failure: true
  needs:
    - g1_srtool
    - create_g1_data
  image: python:3.9.18
  script:
    - echo "Not implemented"
    - exit 1
  tags:
    - kepler

############## RELEASE ##############

create_release:
  stage: gx_release
  rules:
    - when: always
  image: python:3.9.18
  script:
    - echo "Create release page"
  tags:
    - kepler
#create_release:
#  stage: gx_release
#  rules:
#    - when: never
#  image: rust:1-bullseye
#  script:
#    # Release creation + link to artifacts
#    - export G1_DATA_URL="$CI_JOB_URL/artifacts/file/resources/g1-data.json"
#    - export GDEV_WASM_URL="$CI_JOB_URL/artifacts/file/runtime/gdev/target/srtool/release/wbuild/gdev-runtime/gdev_runtime.compact.compressed.wasm"
#    - export SRTOOL_OUTPUT_URL="$CI_JOB_URL/artifacts/file/srtool_output.json"
#    - export GDEV_RAW_SPEC_URL="$CI_JOB_URL/artifacts/file/resources/gdev-raw.json"
#    - cargo xtask release-runtime 600
#  tags:
#    - kepler

# ----- GDEV -----

release_gdev_runtime:
  stage: gx_release
  needs:
    - gdev_srtool
    - create_release
  rules:
    - when: manual
  image: python:3.9.18
  script:
    - echo "Push runtime to release page"
  tags:
    - kepler

release_gdev_6_docker:
  stage: gx_release
  needs:
    - create_release
    - gdev_reboot
  rules:
    - when: manual
  image: python:3.9.18
  script:
    - echo "Create Docker image based on gdev_reboot raw specs"
  tags:
    - kepler

# ----- GTEST -----

release_gtest_runtime:
  stage: gx_release
  needs:
    - gtest_srtool
    - create_release
  rules:
    - when: manual
  image: python:3.9.18
  script:
    - echo "Push runtime to release page"
  tags:
    - kepler

release_gtest_docker:
  stage: gx_release
  needs:
    - create_release
    - gtest_reboot
  rules:
    - when: manual
  image: python:3.9.18
  script:
    - echo "Create Docker image based on gtest_reboot raw specs"
  tags:
    - kepler

# ----- G1 -----

release_g1_runtime:
  stage: gx_release
  needs:
    - g1_srtool
    - create_release
  rules:
    - when: manual
  image: python:3.9.18
  script:
    - echo "Push runtime to release page"
  tags:
    - kepler

release_g1_docker:
  stage: gx_release
  needs:
    - create_release
    - g1_reboot
  rules:
    - when: manual
  image: python:3.9.18
  script:
    - echo "Create Docker image based on g1_reboot raw specs"
  tags:
    - kepler
