# Runner tags:
# - podman: use 'podman' to build multiplatform images

stages:
  - schedule
  - labels
  - quality
  - build
  - tests
  - release
  - deploy
  - deploy_readme

# Job templates for release builds (without tags/image, set by jobs)
.release_rules:
  stage: release
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH =~ /^network\//
      when: manual
    - when: never

.debian_build_template:
  extends: .release_rules
  before_script:
    # Install build dependencies
    - apt-get update -qq && apt-get install -y -qq protobuf-compiler clang libclang-dev
  script:
    - cargo xtask client-build-deb $NETWORK

.rpm_build_template:
  extends: .release_rules
  before_script:
    # Install RPM build tools and dependencies
    - apt-get update -qq && apt-get install -y -qq rpm protobuf-compiler clang libclang-dev
  script:
    - cargo xtask client-build-rpm $NETWORK

.docker_deploy_template:
  extends: .release_rules
  image: docker:latest
  variables:
    DOCKER_HOST: unix:///var/run/docker.sock
  before_script:
    # Install Rust and build dependencies
    - apk add --no-cache curl bash gcc musl-dev
    - curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y --default-toolchain stable --profile minimal
    - source $HOME/.cargo/env
    - docker info
  script:
    - cargo xtask client-docker-deploy $NETWORK --arch $ARCH

# Release build jobs
release_debian_arm:
  extends:
    - .env_arm
    - .debian_build_template
  needs: []
  artifacts:
    paths:
      - target/debian/*.deb

release_debian_x64:
  extends:
    - .env
    - .debian_build_template
  needs: []
  artifacts:
    paths:
      - target/debian/*.deb

release_rpm_arm:
  extends:
    - .env_arm
    - .rpm_build_template
  needs: []
  artifacts:
    paths:
      - target/generate-rpm/*.rpm

release_rpm_x64:
  extends:
    - .env
    - .rpm_build_template
  needs: []
  artifacts:
    paths:
      - target/generate-rpm/*.rpm

release_docker_arm:
  extends: .docker_deploy_template
  needs: []
  tags:
    - linuxARM
  variables:
    ARCH: arm64

release_docker_x64:
  extends: .docker_deploy_template
  needs: []
  tags:
    - kepler
  variables:
    ARCH: amd64

release_docker_manifest:
  stage: release
  rules:
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH =~ /^network\//
      when: on_success  # Auto-start when dependencies succeed
    - when: never
  needs:
    - job: release_docker_arm
      optional: false
    - job: release_docker_x64
      optional: false
  tags:
    - kepler
  image: docker:latest
  variables:
    DOCKER_HOST: unix:///var/run/docker.sock
  before_script:
    - apk add --no-cache bash grep sed
  script:
    - docker login -u duniterteam -p $DUNITERTEAM_PASSWD docker.io
    - |
      # Extract runtime from NETWORK (e.g., gtest-1100 -> gtest)
      RUNTIME=$(echo $NETWORK | sed 's/-[0-9].*//')
      
      # Get client version from node/Cargo.toml
      CLIENT_VERSION=$(grep '^version = ' node/Cargo.toml | head -1 | sed 's/.*"\(.*\)".*/\1/')
      
      # Get runtime version from runtime/$RUNTIME/src/lib.rs
      RUNTIME_VERSION=$(grep 'spec_version:' runtime/$RUNTIME/src/lib.rs | sed 's/.*spec_version: \([0-9]*\).*/\1/')
      
      IMAGE_NAME="duniter/duniter-v2s-${NETWORK}"
      TAG="${RUNTIME_VERSION}-${CLIENT_VERSION}"
      
      echo "Creating multi-arch manifest for ${IMAGE_NAME}:${TAG}"
      
      # Use buildx imagetools to create multi-arch tags from existing images
      # This works even if the source images are manifest lists
      docker buildx imagetools create \
        --tag ${IMAGE_NAME}:${TAG} \
        ${IMAGE_NAME}:${TAG}-amd64 \
        ${IMAGE_NAME}:${TAG}-arm64
      
      echo "✅ Multi-arch tag created: ${IMAGE_NAME}:${TAG}"
      
      # Also create :latest tag
      docker buildx imagetools create \
        --tag ${IMAGE_NAME}:latest \
        ${IMAGE_NAME}:${TAG}-amd64 \
        ${IMAGE_NAME}:${TAG}-arm64
      
      echo "✅ Multi-arch tag created: ${IMAGE_NAME}:latest"

workflow:
  rules:
    - changes:
        - docker/Dockerfile
        - end2end-tests/**/*
        - node/**/*
        - pallets/**/*
        - runtime/**/*
        - .gitlab-ci.yml
        - Cargo.toml
        - Cargo.lock
        - resources/*.yaml

sanity_tests:
  extends: .env
  rules:
    - if: '$CI_PIPELINE_SOURCE == "schedule" && $SCHEDULE_TOPIC=="sanity-tests"'
    - when: never
  stage: schedule
  script:
    - cargo sanity-${CURRENCY}

check_labels:
  extends: .env
  stage: labels
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never
  script:
    - ./scripts/check_labels.sh $CI_MERGE_REQUEST_LABELS $CI_MERGE_REQUEST_MILESTONE

check_metadata:
  extends: .env
  stage: tests
  rules:
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
    - when: never
  script:
    - ./scripts/check_metadata.sh

.env:
  image: paritytech/ci-unified:bullseye-1.88.0
  tags:
    - kepler

.env_arm:
  image: rust:latest  # Rust image for ARM builds
  tags:
    - linuxARM

fmt_and_clippy:
  extends: .env
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^wip*$/
      when: manual
    - if: '$CI_COMMIT_TAG || $CI_COMMIT_BRANCH == "master"'
      when: never
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      when: always
    - when: manual
  stage: quality
  script:
    - cargo fmt -- --version
    - cargo fmt -- --check
    - cargo clippy -- -V
    - cargo clippy -Zgit=shallow-deps --features runtime-benchmarks --all --tests -- -D warnings

run_benchmarks:
  extends: .env
  stage: tests
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^wip*$/
      when: manual
    - if: $CI_COMMIT_TAG
      when: never
    - if: '$CI_MERGE_REQUEST_ID || $CI_COMMIT_BRANCH == "master"'
    - when: manual
  script:
    - cargo build -Zgit=shallow-deps --release --features runtime-benchmarks
    - target/release/duniter benchmark storage --chain=dev --mul=2 --state-version=1 --weight-path=./runtime/g1/src/weights/ --batch-size=100
    - target/release/duniter benchmark overhead --chain=dev --wasm-execution=compiled --warmup=1 --repeat=100 --weight-path=./runtime/g1/src/weights/
    - target/release/duniter benchmark pallet --chain=dev --steps=5 --repeat=2 --pallet="*" --extrinsic="*" --wasm-execution=compiled --output=./runtime/g1/src/weights/
    - cargo build -Zgit=shallow-deps --release --features runtime-benchmarks # Check if autogenerated weights work

gtest_build:
  stage: build
  extends: .env
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^wip*$/
      when: manual
    - if: $CI_COMMIT_TAG
      when: never
    - if: $CI_COMMIT_BRANCH =~ /^(release\/runtime-)[0-9].*/
      when: never
    - if: '$CI_MERGE_REQUEST_ID || $CI_COMMIT_BRANCH == "master"'
    - when: manual
  variables:
    DEBIAN_FRONTEND: noninteractive
  script:
    - cargo build -Zgit=shallow-deps --no-default-features --features gtest

tests:
  stage: tests
  extends: .env
  rules:
    - if: $CI_COMMIT_REF_NAME =~ /^wip*$/
      when: manual
    - if: $CI_COMMIT_TAG
      when: never
    - if: '$CI_MERGE_REQUEST_ID || $CI_COMMIT_BRANCH == "master"'
    - when: manual
  variables:
    DEBIAN_FRONTEND: noninteractive
  script:
    - export RUST_MIN_STACK=16777216 # 16MB stack size otherwise CI fail during LLVM's Thin LTO (Link Time Optimization) phase
    - cargo tu
    - cargo tf
    - cargo cucumber-build
    - cargo cucumber
